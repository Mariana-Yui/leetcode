**2024 目标 跑路 涨薪 减少内耗**

# 刷题笔记

## 二叉树

前中后序遍历(广度遍历)
递归写法
迭代写法 栈

深度遍历(层序遍历)
迭代写法 队列

二叉搜索树
通过中序遍历转化为有序数组

关于二叉树递归是否有返回值, 如何处理返回值, 遍历一边还是一整颗树, 需要好好理解这篇文章
[二叉树的最近公共祖先](https://programmercarl.com/0236.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.html)

递归切忌去模拟完整链路, 入栈出栈过程会晕的
三部曲: 1. 确定递归函数的参数以及返回值 2. 确定终止条件 3. 确定单层递归

二叉树总结
![](https://code-thinking-1253855093.file.myqcloud.com/pics/20211030125421.png)

## 回溯算法

回溯本质是穷举, 可以抽象成树状结构
回溯三部曲:

1. 确定参数和返回值, 回溯比较难确定参数, 一般是边写边加, 缺啥参数加啥; 回溯一般没有返回值
2. 确定终止条件
3. 单层递归逻辑

```
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```

组合问题
先把完整逻辑写完, 然后再进行剪枝操作

什么时候用到`startIndex`?
一个集合取组合用`startIndex`
多个集合互不干扰取组合不用`startIndex`

经典+难的回溯问题
N 皇后问题
数独问题

## 贪心算法

取局部最优得到全局最优, 没有套路模板, 觉得可以用贪心就试试, 万一对了呢?
局部最优 推导 全局最优 不需要数学推导, AC 就行

## 动态规划

DP 五部曲:

1. 确定 dp 数组及下标的含义
2. 确定递推公式/状态转移公式
3. dp 数组如何初始化
4. 确定遍历顺序
5. 举例推导 dp 数组

01 背包问题
背包问题状态都是可以压缩的
01 背包问题一维 dp 的遍历，物品正序, 背包倒序

01 背包可以处理组合求和的个数问题, 如果要求路径集合还是要用回溯

为什么01背包的一维数组写法背包j遍历需要从后往前?
如果是从前往后会发生什么?
举个例子: 物品0: 重量1, 价值15; 物品1: 重量3, 价值20;
从前往后: 
第一轮物品0: dp[1] = dp[0] + 15 = 15
第二轮物品1: dp[2] = dp[2-1] + 15 = 30
这里就发现出问题了, dp[1]被重复使用了, 但是物品都只有1份, 不能重复放入背包
从后向前:
第一轮物品0: dp[2] = dp[2-1] + 15 = 0 + 15 = 15

完全背包和01背包唯一的区别在于遍历方式
完全背包的一维数组写法背包j遍历则是从前往后
因为完全背包每个物品都有无数个, 从上面的例子可以看出, 完全背包是允许dp[1]重复使用的

完全背包问题
求组合 外循环遍历物品 内循环遍历背包
求排列 外循环遍历背包 内循环遍历物品
以数组[1,2,5] target=5为例
外循环遍历物品, 每个物品只遍历一次, 所以结果存在1+2+2=5
内循环遍历物品, 每个物品会遍历多次, 会得到1+2+2=5, 2+1+2=5, 2+2+1=5

总结
能否装满背包 or 最多装多少个: dp[j] = max(dp[j], dp[j - nums[i]] + nums[i])
问装满背包有几种方法：dp[j] += dp[j - nums[i]]
背包装满最大价值：dp[j] = max(dp[j], dp[j - weight[i]] + value[i])
装满背包所有物品的最小个数：dp[j] = min(dp[j - coins[i]] + 1, dp[j])